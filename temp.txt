с, [23.01.2025 8:13]
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    telegram_id BIGINT UNIQUE NOT NULL,
    username VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE wallets (
    id SERIAL PRIMARY KEY,
    user_id INT REFERENCES users(id),
    currency VARCHAR(10) NOT NULL,
    balance DECIMAL(20, 8) DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE transactions (
    id SERIAL PRIMARY KEY,
    user_id INT REFERENCES users(id),
    wallet_id INT REFERENCES wallets(id),
    amount DECIMAL(20, 8) NOT NULL,
    transaction_type VARCHAR(10) NOT NULL, -- 'deposit', 'withdraw', 'exchange'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

с, [23.01.2025 8:13]
const express = require('express');
const bodyParser = require('body-parser');
const { Pool } = require('pg');
require('dotenv').config();

const app = express();
const port = process.env.PORT || 3000;

app.use(bodyParser.json());

const pool = new Pool({
    connectionString: process.env.DATABASE_URL,
});

// Эндпоинт для регистрации пользователя
app.post('/register', async (req, res) => {
    const { telegram_id, username } = req.body;
    try {
        const result = await pool.query('INSERT INTO users (telegram_id, username) VALUES ($1, $2) RETURNING *', [telegram_id, username]);
        res.status(201).json(result.rows[0]);
    } catch (error) {
        res.status(500).json({ error: 'Ошибка регистрации пользователя' });
    }
});

// Эндпоинт для пополнения счета
app.post('/deposit', async (req, res) => {
    const { user_id, currency, amount } = req.body;
    try {
        const result = await pool.query('UPDATE wallets SET balance = balance + $1 WHERE user_id = $2 AND currency = $3 RETURNING *', [amount, user_id, currency]);
        await pool.query('INSERT INTO transactions (user_id, wallet_id, amount, transaction_type) VALUES ($1, $2, $3, $4)', [user_id, result.rows[0].id, amount, 'deposit']);
        res.status(200).json(result.rows[0]);
    } catch (error) {
        res.status(500).json({ error: 'Ошибка пополнения счета' });
    }
});

// Запуск сервера
app.listen(port, () => {
    console.log(Сервер запущен на http://localhost:${port});
});

с, [23.01.2025 8:13]
const TelegramBot = require('node-telegram-bot-api');
const axios = require('axios');
require('dotenv').config();

const bot = new TelegramBot(process.env.TELEGRAM_TOKEN, { polling: true });

bot.onText(/\/start/, (msg) => {
    const chatId = msg.chat.id;
    bot.sendMessage(chatId, 'Добро пожаловать в криптовалютный кошелек! Используйте /register для регистрации.');
});

bot.onText(/\/register/, async (msg) => {
    const chatId = msg.chat.id;
    const username = msg.from.username;

    try {
        const response = await axios.post('http://localhost:3000/register', {
            telegram_id: chatId,
            username: username,
        });
        bot.sendMessage(chatId, Вы успешно зарегистрированы! Ваш ID: ${response.data.id});

с, [23.01.2025 8:14]
// Эндпоинт для регистрации пользователя
app.post('/register', async (req, res) => {
    const { telegram_id, username } = req.body;
    try {
        const result = await pool.query('INSERT INTO users (telegram_id, username) VALUES ($1, $2) RETURNING *', [telegram_id, username]);
        const userId = result.rows[0].id;

        // Создание кошелька для нового пользователя
        const currencies = ['TON', 'USDT', 'NOT', 'BTC', 'ETH', 'SOL', 'TRX', 'DOGE'];
        for (const currency of currencies) {
            await pool.query('INSERT INTO wallets (user_id, currency) VALUES ($1, $2)', [userId, currency]);
        }

        res.status(201).json(result.rows[0]);
    } catch (error) {
        res.status(500).json({ error: 'Ошибка регистрации пользователя' });
    }
});

с, [23.01.2025 8:14]
// Эндпоинт для пополнения счета
app.post('/deposit', async (req, res) => {
    const { user_id, currency, amount } = req.body;
    try {
        const result = await pool.query('UPDATE wallets SET balance = balance + $1 WHERE user_id = $2 AND currency = $3 RETURNING *', [amount, user_id, currency]);
        await pool.query('INSERT INTO transactions (user_id, wallet_id, amount, transaction_type) VALUES ($1, $2, $3, $4)', [user_id, result.rows[0].id, amount, 'deposit']);
        res.status(200).json(result.rows[0]);
    } catch (error) {
        res.status(500).json({ error: 'Ошибка пополнения счета' });
    }
});

с, [23.01.2025 8:14]
// Эндпоинт для вывода средств
app.post('/withdraw', async (req, res) => {
    const { user_id, currency, amount } = req.body;
    try {
        const walletResult = await pool.query('SELECT * FROM wallets WHERE user_id = $1 AND currency = $2', [user_id, currency]);
        const wallet = walletResult.rows[0];

        if (wallet.balance < amount) {
            return res.status(400).json({ error: 'Недостаточно средств на счете' });
        }

        await pool.query('UPDATE wallets SET balance = balance - $1 WHERE user_id = $2 AND currency = $3', [amount, user_id, currency]);
        await pool.query('INSERT INTO transactions (user_id, wallet_id, amount, transaction_type) VALUES ($1, $2, $3, $4)', [user_id, wallet.id, amount, 'withdraw']);
        res.status(200).json({ message: 'Вывод средств выполнен успешно' });
    } catch (error) {
        res.status(500).json({ error: 'Ошибка вывода средств' });
    }
});

с, [23.01.2025 8:14]
// Эндпоинт для обмена валют
app.post('/exchange', async (req, res) => {
    const { user_id, from_currency, to_currency, amount } = req.body;
    try {
        const fromWalletResult = await pool.query('SELECT * FROM wallets WHERE user_id = $1 AND currency = $2', [user_id, from_currency]);
        const toWalletResult = await pool.query('SELECT * FROM wallets WHERE user_id = $1 AND currency = $2', [user_id, to_currency]);
        const fromWallet = fromWalletResult.rows[0];
        const toWallet = toWalletResult.rows[0];

        if (fromWallet.balance < amount) {
            return res.status(400).json({ error: 'Недостаточно средств для обмена' });
        }

        // Здесь можно добавить логику для расчета курса обмена
        const exchangeRate = 1; // Пример фиксированного курса
        const exchangedAmount = amount * exchangeRate;

        await pool.query('UPDATE wallets SET balance = balance - $1 WHERE user_id = $2 AND currency = $3', [amount, user_id, from_currency]);
        await pool.query('UPDATE wallets SET balance = balance + $1 WHERE user_id = $2 AND currency = $3', [exchangedAmount, user_id, to_currency]);
        await pool.query('INSERT INTO transactions (user_id, wallet_id, amount, transaction_type) VALUES ($1, $2, $3, $4)', [user_id, fromWallet.id, amount, 'exchange']);
        await pool.query('INSERT INTO transactions (user_id, wallet_id, amount, transaction_type) VALUES ($1, $2, $3, $4)', [user_id, toWallet.id, exchangedAmount, 'exchange']);

        res.status(200).json({ message: 'Обмен валют выполнен успешно', exchangedAmount });
    } catch (error) {
        res.status(500).json({ error: 'Ошибка обмена валют' });
    }
});

с, [23.01.2025 8:14]
CREATE TABLE p2p_requests (
    id SERIAL PRIMARY KEY,
    user_id INT REFERENCES users(id),
    currency VARCHAR(10) NOT NULL,
    amount DECIMAL(20, 8) NOT NULL,
    price DECIMAL(20, 8) NOT NULL,
    request_type VARCHAR(10) NOT NULL, -- 'buy' or 'sell'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

// Эндпоинт для создания P2P-запроса
app.post('/p2p', async (req, res) => {
    const { user_id, currency, amount, price, request_type } = req.body;
    try {
        const result = await pool.query('INSERT INTO p2p_requests (user_id, currency, amount, price, request_type) VALUES ($1, $2, $3, $4, $5) RETURNING *', [user_id, currency, amount, price, request_type]);
        res.status(201).json(result.rows[0]);
    } catch (error) {
        res.status(500).json({ error: 'Ошибка создания P2P-запроса' });
    }
});

с, [23.01.2025 8:14]
// Эндпоинт для получения истории транзакций
app.get('/transactions/:user_id', async (req, res) => {
    const { user_id } = req.params;
    try {
        const result = await pool.query('SELECT * FROM transactions WHERE user_id = $1 ORDER BY created_at DESC', [user_id]);
        res.status(200).json(result.rows);
    } catch (error) {
        res.status(500).json({ error: 'Ошибка получения истории транзакций' });
    }
});

с, [23.01.2025 8:16]
const { ethers } = require('ethers');

// Генерация нового адреса кошелька
const wallet = ethers.Wallet.createRandom();
const address = wallet.address; // Сохраняем этот адрес в базе данных

с, [23.01.2025 8:16]
// Эндпоинт для регистрации пользователя
app.post('/register', async (req, res) => {
    const { telegram_id, username } = req.body;
    try {
        const result = await pool.query('INSERT INTO users (telegram_id, username) VALUES ($1, $2) RETURNING *', [telegram_id, username]);
        const userId = result.rows[0].id;

        // Генерация адреса кошелька для Ethereum
        const wallet = ethers.Wallet.createRandom();
        const ethAddress = wallet.address;

        // Сохранение адреса в базе данных
        await pool.query('INSERT INTO wallets (user_id, currency, address) VALUES ($1, $2, $3)', [userId, 'ETH', ethAddress]);

        res.status(201).json(result.rows[0]);
    } catch (error) {
        res.status(500).json({ error: 'Ошибка регистрации пользователя' });
    }
});

с, [23.01.2025 8:17]
const axios = require('axios');

// Функция для проверки баланса
async function checkBalance() {
    const wallets = await pool.query('SELECT * FROM wallets WHERE currency = $1', ['ETH']);

    for (const wallet of wallets.rows) {
        const address = wallet.address;

        // Запрос к Etherscan API для получения баланса
        const response = await axios.get(https://api.etherscan.io/api?module=account&action=balance&address=${address}&tag=latest&apikey=${process.env.ETHERSCAN_API_KEY});

        const balance = response.data.result / 1e18; // Преобразование из Wei в ETH

        // Обновление баланса в базе данных
        await pool.query('UPDATE wallets SET balance = $1 WHERE id = $2', [balance, wallet.id]);
    }
}

// Запуск проверки баланса каждые 60 секунд
setInterval(checkBalance, 60000);

с, [23.01.2025 8:17]
async function checkBalance() {
    const wallets = await pool.query('SELECT * FROM wallets WHERE currency = $1', ['ETH']);

    for (const wallet of wallets.rows) {
        const address = wallet.address;

        // Запрос к Etherscan API для получения баланса
        const response = await axios.get(https://api.etherscan.io/api?module=account&action=balance&address=${address}&tag=latest&apikey=${process.env.ETHERSCAN_API_KEY});

        const newBalance = response.data.result / 1e18; // Преобразование из Wei в ETH

        // Проверка, увеличился ли баланс
        if (newBalance > wallet.balance) {
            const amount = newBalance - wallet.balance;

            // Обновление баланса в базе данных
            await pool.query('UPDATE wallets SET balance = $1 WHERE id = $2', [newBalance, wallet.id]);

            // Запись транзакции
            await pool.query('INSERT INTO transactions (user_id, wallet_id, amount, transaction_type) VALUES ($1, $2, $3, $4)', [wallet.user_id, wallet.id, amount, 'deposit']);
        }
    }
}

с, [23.01.2025 8:18]
async function notifyUser (userId, amount) {
    // Здесь можно использовать любой метод уведомления, например, через Telegram API
    const message = Ваш баланс был пополнен на сумму: ${amount} ETH;

    await sendTelegramMessage(userId, message);
}

async function checkBalance() {
    const wallets = await pool.query('SELECT * FROM wallets WHERE currency = $1', ['ETH']);

    for (const wallet of wallets.rows) {
        const address = wallet.address;

        // Запрос к Etherscan API для получения баланса
        const response = await axios.get(https://api.etherscan.io/api?module=account&action=balance&address=${address}&tag=latest&apikey=${process.env.ETHERSCAN_API_KEY});

        const newBalance = response.data.result / 1e18; // Преобразование из Wei в ETH

        // Проверка, увеличился ли баланс
        if (newBalance > wallet.balance) {
            const amount = newBalance - wallet.balance;

            // Обновление баланса в базе данных
            await pool.query('UPDATE wallets SET balance = $1 WHERE id = $2', [newBalance, wallet.id]);

            // Запись транзакции
            await pool.query('INSERT INTO transactions (user_id, wallet_id, amount, transaction_type) VALUES ($1, $2, $3, $4)', [wallet.user_id, wallet.id, amount, 'deposit']);

            // Уведомление пользователя
            await notifyUser (wallet.user_id, amount);
        }
    }
}

с, [23.01.2025 9:05]
const { ethers } = require('ethers');
const bitcoin = require('bitcoinjs-lib');
const { TonClient } = require('@tonclient/core');

// Генерация адресов для разных криптовалют
async function generateWallets(userId) {
    // Ethereum
    const ethWallet = ethers.Wallet.createRandom();
    const ethAddress = ethWallet.address;

    // Bitcoin
    const btcKeyPair = bitcoin.ECPair.makeRandom();
    const { address: btcAddress } = bitcoin.payments.p2pkh({ pubkey: btcKeyPair.publicKey });

    // TON (пример, может потребоваться дополнительная настройка)
    const tonClient = new TonClient({ network: { server_address: "net.ton.dev" } });
    const tonWallet = await tonClient.wallets.create({ mnemonic: "your mnemonic here" });
    const tonAddress = tonWallet.address;

    // Сохранение адресов в базе данных
    await pool.query('INSERT INTO wallets (user_id, currency, address) VALUES ($1, $2, $3)', [userId, 'ETH', ethAddress]);
    await pool.query('INSERT INTO wallets (user_id, currency, address) VALUES ($1, $2, $3)', [userId, 'BTC', btcAddress]);
    await pool.query('INSERT INTO wallets (user_id, currency, address) VALUES ($1, $2, $3)', [userId, 'TON', tonAddress]);
}

с, [23.01.2025 9:05]
const axios = require('axios');

// Функция для проверки баланса
async function checkBalance() {
    const wallets = await pool.query('SELECT * FROM wallets');

    for (const wallet of wallets.rows) {
        const address = wallet.address;
        let newBalance = 0;

        switch (wallet.currency) {
            case 'ETH':
                const ethResponse = await axios.get(https://api.etherscan.io/api?module=account&action=balance&address=${address}&tag=latest&apikey=${process.env.ETHERSCAN_API_KEY});
                newBalance = ethResponse.data.result / 1e18; // Преобразование из Wei в ETH
                break;

            case 'BTC':
                const btcResponse = await axios.get(https://blockchain.info/q/addressbalance/${address});
                newBalance = btcResponse.data / 1e8; // Преобразование из Satoshi в BTC
                break;

            case 'TON':
                // Пример запроса для TON (может потребоваться дополнительная настройка)
                const tonResponse = await axios.get(https://tonapi.io/v1/getAddressBalance?address=${address});
                newBalance = tonResponse.data.balance; // Предполагается, что API возвращает баланс в TON
                break;

            // Добавьте аналогичные блоки для других валют (USDT, SOL, TRX, DOGE)
            // Например, для USDT можно использовать API Tether, для SOL - Solana API и т.д.

            default:
                console.log(Неизвестная валюта: ${wallet.currency});
                continue;
        }

        // Проверка, увеличился ли баланс
        if (newBalance > wallet.balance) {
            const amount = newBalance - wallet.balance;

            // Обновление баланса в базе данных
            await pool.query('UPDATE wallets SET balance = $1 WHERE id = $2', [newBalance, wallet.id]);

            // Запись транзакции
            await pool.query('INSERT INTO transactions (user_id, wallet_id, amount, transaction_type) VALUES ($1, $2, $3, $4)', [wallet.user_id, wallet.id, amount, 'deposit']);

            // Уведомление пользователя
            await notifyUser (wallet.user_id, amount);
        }
    }
}

с, [23.01.2025 9:06]
const solanaWeb3 = require('@solana/web3.js');

async function getSOLBalance(address) {
    const connection = new solanaWeb3.Connection(solanaWeb3.clusterApiUrl('mainnet-beta'), 'confirmed');
    const publicKey = new solanaWeb3.PublicKey(address);
    const balance = await connection.getBalance(publicKey);
    return balance / solanaWeb3.LAMPORTS_PER_SOL; // Преобразование из лампортов в SOL
}

с, [23.01.2025 9:06]
async function getUSDTBalance(address) {
    const response = await axios.get(https://api.etherscan.io/api?module=account&action=balance&address=${address}&tag=latest&apikey=${process.env.ETHERSCAN_API_KEY});
    return response.data.result / 1e18; // Преобразование из Wei в USDT
}

с, [23.01.2025 9:07]
async function getTRXBalance(address) {
    const response = await axios.get(https://api.tronscan.org/api/account?address=${address});
    return response.data.data[0].balance / 1e6; // Преобразование из SUN в TRX
}

с, [23.01.2025 9:07]
async function getDOGEBalance(address) {
    const response = await axios.get(https://api.blockcypher.com/v1/doge/main/addrs/${address}/balance);
    return response.data.final_balance / 1e8; // Преобразование из Satoshi в DOGE
}

с, [23.01.2025 9:07]
async function checkBalance() {
    const wallets = await pool.query('SELECT * FROM wallets');

    for (const wallet of wallets.rows) {
        const address = wallet.address;
        let newBalance = 0;

        switch (wallet.currency) {
            case 'ETH':
                newBalance = await getETHBalance(address);
                break;

            case 'BTC':
                newBalance = await getBTCBalance(address);
                break;

            case 'TON':
                newBalance = await getTONBalance(address);
                break;

            case 'USDT':
                newBalance = await getUSDTBalance(address);
                break;

            case 'SOL':
                newBalance = await getSOLBalance(address);
                break;

            case 'TRX':
                newBalance = await getTRXBalance(address);
                break;

            case 'DOGE':
                newBalance = await getDOGEBalance(address);
                break;

            default:
                console.log(Неизвестная валюта: ${wallet.currency});
                continue;
        }

        // Проверка, увеличился ли баланс
        if (newBalance > wallet.balance) {
            const amount = newBalance - wallet.balance;

            // Обновление баланса в базе данных
            await pool.query('UPDATE wallets SET balance = $1 WHERE id = $2', [newBalance, wallet.id]);

            // Запись транзакции
            await pool.query('INSERT INTO transactions (user_id, wallet_id, amount, transaction_type) VALUES ($1, $2, $3, $4)', [wallet.user_id, wallet.id, amount, 'deposit']);

            // Уведомление пользователя
            await notifyUser (wallet.user_id, amount);
        }
    }
}